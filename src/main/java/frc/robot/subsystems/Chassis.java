// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import java.security.AuthProvider;

import com.kauailabs.navx.frc.AHRS;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import com.revrobotics.RelativeEncoder;

import edu.wpi.first.wpilibj.SPI.Port;
import edu.wpi.first.math.kinematics.DifferentialDriveOdometry;
import edu.wpi.first.math.util.Units;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;
import edu.wpi.first.wpilibj.smartdashboard.Field2d;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.RobotContainer;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class Chassis extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private CANSparkMax rightFrontMotor;
    private CANSparkMax rightBackMotor;
    private MotorControllerGroup rightMotors;
    private CANSparkMax leftFrontMotor;
    private CANSparkMax leftBackMotor;
    private MotorControllerGroup leftMotors;
    private DifferentialDrive differentialDrive;

    // Odometry class for tracking robot pose
    private final DifferentialDriveOdometry odometry;

    // Also show a field diagram
    private  Field2d field2d;

    private double leftOffSet = 0;
    private double rightOffSet = 0;
    private RelativeEncoder rightEncoder;
    private RelativeEncoder leftEncoder;
    public static AHRS navXBoard;

    private Vision m_vision;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    /**
    *
    */
    public Chassis(Vision v) {
        m_vision = v;

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        navXBoard = new AHRS(Port.kMXP);
        rightFrontMotor = new CANSparkMax(4, MotorType.kBrushless);

        rightFrontMotor.restoreFactoryDefaults();
        rightFrontMotor.setInverted(false);
        rightFrontMotor.setIdleMode(IdleMode.kCoast);

        rightBackMotor = new CANSparkMax(5, MotorType.kBrushless);

        rightBackMotor.restoreFactoryDefaults();
        rightBackMotor.setInverted(false);
        rightBackMotor.setIdleMode(IdleMode.kCoast);

        rightMotors = new MotorControllerGroup(rightFrontMotor, rightBackMotor);
        addChild("rightMotors", rightMotors);

        leftFrontMotor = new CANSparkMax(2, MotorType.kBrushless);

        leftFrontMotor.restoreFactoryDefaults();
        leftFrontMotor.setInverted(false);
        leftFrontMotor.setIdleMode(IdleMode.kCoast);

        leftBackMotor = new CANSparkMax(3, MotorType.kBrushless);

        leftBackMotor.restoreFactoryDefaults();
        leftBackMotor.setInverted(false);
        leftBackMotor.setIdleMode(IdleMode.kCoast);

        leftMotors = new MotorControllerGroup(leftFrontMotor, leftBackMotor);
        addChild("leftMotors", leftMotors);

        differentialDrive = new DifferentialDrive(leftMotors, rightMotors);
        addChild("differentialDrive", differentialDrive);
        differentialDrive.setSafetyEnabled(true);
        differentialDrive.setExpiration(0.1);
        differentialDrive.setMaxOutput(1.0);

        rightEncoder = rightFrontMotor.getEncoder();
        leftEncoder = leftFrontMotor.getEncoder();
        resetEncoder();
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        //m_vision = RobotContainer.getInstance().m_Vision;
        odometry = new DifferentialDriveOdometry(Rotation2d.fromDegrees(getAngle()), 0.0, 0.0);
        field2d = new Field2d();
        // field2d = RobotContainer.getInstance().m_Vision.Field;
        //odometry.resetPosition(null, rightOffSet, leftOffSet, getPose());

    }

    public double getAngle() {
        return navXBoard.getAngle();

    }

    @Override
    public void periodic() {
        SmartDashboard.putNumber("getEncoderDistance", getEncoderDistance());
        SmartDashboard.putNumber("getLeftDistance", leftDistanceTraveled());
        SmartDashboard.putNumber("getRightDistance", rightDistanceTraveled());
        SmartDashboard.putData("NavX", navXBoard);
        SmartDashboard.putNumber("Angle", getAngle());

        Rotation2d gyroAngleRadians = Rotation2d.fromDegrees(getAngle());
        double leftDistanceMeters = leftDistanceTraveled();
        double rightDistanceMeters = rightDistanceTraveled();
        odometry.update(gyroAngleRadians, leftDistanceMeters, rightDistanceMeters);

        if (m_vision.hasTarget()) {
            odometry.resetPosition(
                gyroAngleRadians, 
                leftDistanceMeters, rightDistanceMeters, 
                m_vision.Field.getRobotPose()
            );
        } else {
            m_vision.setLastPose(getPose());
        }
        Pose2d currentPose = getPose();
        field2d.setRobotPose(currentPose);
        SmartDashboard.putData("Odometry Position",field2d);
    }

    @Override
    public void simulationPeriodic() {

        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void arcadeDrive(double speed, double rotation) {

        differentialDrive.arcadeDrive(rotation, speed);
    }

    public void getEncoder() {

    }

    public void resetEncoder() {
        leftOffSet = leftEncoder.getPosition();
        rightOffSet = rightEncoder.getPosition();
    }

    public double getEncoderDistance() {
        double meters = ((leftEncoder.getPosition() - leftOffSet) + (rightEncoder.getPosition() * -1 - rightOffSet))
                / 2;

        return meters;
    }

    public double leftDistanceTraveled() {
        return (leftEncoder.getPosition() - leftOffSet) / 19;
    }

    public double rightDistanceTraveled() {
        return ((rightEncoder.getPosition() - rightOffSet) * -1) / 19;
    }

    public Pose2d getPose() {
        return odometry.getPoseMeters();
    }

    public void resetOdometry(Pose2d pose) {
        resetEncoder();
        odometry.resetPosition(Rotation2d.fromDegrees(getAngle()), 0.0, 0.0, pose);
    }
}
